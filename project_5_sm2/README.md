# SM2算法实现、PoC验证与虚构场景签名伪造全流程说明

## 一、SM2算法核心实现与数学原理

### 1.1 椭圆曲线参数定义
SM2采用256位椭圆曲线，推荐参数如下：
- **素数域**：  
  $p = 0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3$
  
- **曲线方程**：  
  $y^2 = x^3 + ax + b \mod p$  
  - $a = 0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498$  
  - $b = 0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A$
  
- **基点**：$G = (Gx, Gy)$  
  - $Gx = 0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D$  
  - $Gy = 0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2$
  
- **阶数**：  
  $n = 0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7$

### 1.2 密钥生成
1. **私钥生成**：随机选择 $d \in [1, n-2]$  
   ```python
   d = secrets.randbelow(n-1) + 1  # 确保1 ≤ d ≤ n-1
   ```

2. **公钥生成**：通过椭圆曲线点乘法计算 $Q = d \cdot G$  
   - 数学原理：点乘法是多次点加法的累积，即 $d \cdot G = G + G + \dots + G$（共d次）  
   - 实现函数：`point_mul(d, G)`

### 1.3 签名算法
对消息 $M$ 生成签名 $(r, s)$ 的步骤：

1. **计算用户信息哈希 $Z_A$**  
   $Z_A = SM3(entl || ID || a || b || Gx || Gy || x_A || y_A)$  
   - $entl$：ID长度（位）  
   - $x_A, y_A$：公钥 $Q$ 的坐标

2. **计算消息哈希 $e$**  
   $e = SM3(Z_A || M)$ → $e_{int} = bytes_to_int(e)$

3. **生成随机数 $k$ 并计算曲线点**  
   - 随机选择 $k \in [1, n-1]$  
   - 计算 $(x_1, y_1) = k \cdot G$

4. **计算签名组件 $r$ 和 $s$**  
   $r = (e_{int} + x_1) \mod n$  
   $s = \left( (1 + d)^{-1} \cdot (k - r \cdot d) \right) \mod n$  
   - 若 $r = 0$ 或 $s = 0$，重新生成 $k$

### 1.4 验签算法
验证签名 $(r, s)$ 有效性的步骤：

1. **范围检查**：验证 $r, s \in [1, n-1]$
2. **计算哈希值**：同签名步骤，计算 $Z_A$ 和 $e_{int}$
3. **计算验证参数**  
   $t = (r + s) \mod n$（若 $t = 0$ 则无效）  
   $(x_1, y_1) = s \cdot G + t \cdot Q$
4. **最终验证**  
   $R = (e_{int} + x_1) \mod n$（若 $R = r$ 则签名有效）

## 二、PoC验证：随机数漏洞导致私钥泄露

### 2.1 漏洞原理推导
当同一随机数 $k$ 被用于两个消息 $M_1$ 和 $M_2$ 的签名时：

1. 生成两组签名 $(r_1, s_1)$ 和 $(r_2, s_2)$，满足：  
   $s_1 \cdot (1 + d) = k - r_1 \cdot d \mod n$  ...(1)  
   $s_2 \cdot (1 + d) = k - r_2 \cdot d \mod n$  ...(2)

2. 两式相减消去 $k$：  
   $(s_1 - s_2) \cdot (1 + d) = (r_2 - r_1) \cdot d \mod n$

3. 整理得到私钥推导公式：  
   $d = \frac{s_2 - s_1}{s_1 - s_2 + r_1 - r_2} \mod n$

### 2.2 实验验证过程
1. **参数输入**  
   - 私钥 $d = 0x3c4ff4d037978e697f0a7d79802674e6c208b79661729f456f75d4d2ebee4ff3$  
   - 固定随机数 $k$  
   - 消息 $M_1 = "虚构消息1：Hello World"$，$M_2 = "虚构消息2：Crypto Demo"$

2. **生成签名**  
   - 签名1：$(r_1, s_1) = (0x415f8e5f..., 0x764bd893...)$  
   - 签名2：$(r_2, s_2) = (0x3f8902f6..., 0x1604bf4d...)$

3. **私钥推导计算**  
   - 分子：$s_2 - s_1 \mod n = 0x1604bf4d... - 0x764bd893... \mod n$  
   - 分母：$(s_1 - s_2 + r_1 - r_2) \mod n$  
   - 模逆运算：$分母^{-1} \mod n$  
   - 结果：$d_{推导} = 0x3c4ff4d0...$（与原始私钥完全一致）

## 三、虚构场景签名伪造（纯技术模拟）

### 3.1 伪造原理
获取私钥 $d$ 后，攻击者可直接使用SM2签名算法生成任意消息的"合法"签名，步骤与正常签名完全一致。

### 3.2 伪造步骤与计算
1. **输入参数**  
   - 推导的私钥 $d$  
   - 伪造消息 $M_{伪造} = "伪造的虚构消息：This is a demo"$

2. **生成伪造签名**  
   - 生成新随机数 $k'$  
   - 计算 $(x_1', y_1') = k' \cdot G$  
   - 计算 $r' = (e'_{int} + x_1') \mod n$  
   - 计算 $s' = \left( (1 + d)^{-1} \cdot (k' - r' \cdot d) \right) \mod n$

3. **验证结果**  
   - 伪造签名：$(r', s') = (0x72abd72d..., 0x1d97801a...)$  
   - 验证结果：`True`（通过公钥验证）

## 四、结论与安全启示

1. **核心结论**  
   - SM2签名安全性完全依赖随机数 $k$ 的唯一性和保密性  
   - 重复使用 $k$ 会直接导致私钥泄露，进而允许攻击者伪造签名

2. **防御措施**  
   - 使用加密安全随机数生成器（如`secrets`模块）  
   - 每次签名必须重新生成 $k$，推荐遵循RFC6979标准  
   - 采用抗侧信道攻击的点乘法实现（如蒙哥马利梯子法）